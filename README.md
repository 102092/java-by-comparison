# 참고
- 웹 페이지: https://pragprog.com/titles/javacomp
- 토론 포럼: http://forums.pragprog.com/forums/javacomp
- 정오표: http://pragprog.com/titles/javacomp/errata
- 소스 코드: https://pragprog.com/titles/javacomp/source_code
- 길벗 홈페이지: https://www.gilbut.co.kr
- 길벗 소스 코드: https://github.com/gilbutITbook/007025

## 실습 준비 사항
실습에는 다음 준비 사항이 필요합니다.
- JDK 8 이상의 컴파일러
- 텍스트 에디터
- 빌드를 위한 Gradle
- 맑은 정신!(원서의 유머)

## 예제 파일 구조 및 참고 사항
이 책에서 사용하는 예제 파일은 주제별로 분류되어 있습니다.

- src
  - comments | 3장
  - design     | 7장         
  - error_handling | 5장
  - general         | 1장, 2장
  - lambdas | 8장
  - naming | 4장
  - preface | 서문
  - realworld  | 9장
  - testing | 6장

--- 

# Intro
- [x] FizzBuzzTest

# 1. 코드 정리
## 1.1  쓸모 없는 비교 피하기
- if-else문에서 return값이 boolean인 경우 굳이 비교할 필요 없음.

## 1.2 부정 피하기
- 불연산자(!) 를 사용하지 말자 -> 가독성에 별로 안 좋음.
-  누구나 부정이 없는 표현을 좋아한다.

## 1.3 불(boolean) 표현식은 직접 반환하자
- true, false를 리턴하기 보다는, 그 표현식 자체를 리턴하도록 리팩토링하자
- 드 모르간의 법칙
    - `!A && !B == !(A || B)`
    - `!A || !B == !(A && B)`
- 조건문이 세 개 이상 합칠 떄는, 변수로 따로 빼서 최적화를 시도하자

## 1.4 불 표현식 간소화
- 여러 조건문이 합쳐져 있으면, 이해하기 어려움 혹은 잘못 이해할 가능성 높음.
- &&가 항상  || 보다 먼저 평가된다.

## 1.5 조건문에서 NullPointerException 피하기
- 인수를 검증할 떄는 순서가 중요.
    - 반드시 `null` 을 먼저 확인한 후에, 다른 유효하지 않은 값을 검사해야함.
- 매개 변수 검사는 public, protected, default 메서드에서만 하면 됨.

## 1.6 스위치(switch) 실패 피하기
- case 문에 `break`가 없으면, 그대로 진행됨.

## 1.7 항상 괄호 사용하기
- if문 body에는 항상 `{}`를 사용하자
- 그래야 코드 가독성이 더 좋음 (들여쓰기..)

## 1.8 코드 대칭 이루기
- if문의 분기들이, 모두 비슷한 관심사를 표현하는가..?
- 첫번째는 유저 상태에 따라서, 로그인을 거절함
- 두번쨰, 세번쨰는 유저의 상태에 따라서 접근을 허락함.
    - 즉 접근이라는 관심사에 대해 서로 다른 입장을 표명하고 있음을 알 수 있음.
    - 이를 코드 대칭적으로 나타내려면..
    
# 2. 코드 스타일 정리
## 2.1 매직넘버를 상수로 대체
- 표면상 의미 없는 숫자 -> 매직넘버
- 이러한 숫자를 통해 코드를 제어하면.. 해당 코드 이해가 힘들어짐 
    - 그래서 이를 상수(constant) 대체
    - enum or static final..로.
    
## 2.2 정수 상수 대신에 열거형으로
- static final... 로 선언하기 보다는 enum 으로

## 2.3 For loop 대신 For-Each
- `IndexOutOfBoundsException` 을 피할 수 있음 -> 더 안전해짐

## 2.4 순회하며 컬렉션을 수정하지 말자
- `ConcurrentModificationException` 발생 가능
    - List를 순회하면서, List를 수정할 수는 없다.
- 이 문제의 핵심은, 문제가 발생하기 전에는 알기가 힘들다는 것 (컴파일러가 잡아내지 못한다는 의미인듯)
- `Iterator`를 활용하여 해결할 수 있음.
    - Iterator는 포인터처럼 동작
    - `removeIf()` 도 내부적으로는 Iterator를 사용하는듯.
    
## 2.5 순회하며 계산 집약적 연산 수행하지 않기
- 계산 집약적 연산? 
    - `Pattern.matches`... 같은
    - 루프 돌면서, 계속 특수한 목적의 오토마톤을 만드는데 이는 굉장한 자원을 소모한다.
- Pattern.compile로 미리 만들어두자..
- 아무튼 `Pattern` 클래스를 사용할 떄는 성능 조심하자
    
## 2.6 새 줄로 그루핑
- 연관된 코드, 개념은 그룹핑
- 서로 다른 그룹은 빈 줄을 추가하여 각각 나눠야함.

## 2.7 이어붙이기 대신에 서식화..
- `String.format` 을 이용해서 코드를 간소화 시키자.
- %s -> string, %tm -> time month, %te -> time day, %ty -> time year
- %d -> digit
- %S -> 객체를 toString() 메서드를 이용해 대문자 String 으로 변환
- %n -> 행바꿈 기호
- 문자열이 길면 `StringTemplate`을 사용하자
    -  참고 : https://www.programcreek.com/java-api-examples/?api=org.antlr.stringtemplate.StringTemplate
    
## 2.8 직접 만들지 말고 자바 API를 사용하자
- `Objects`, `Collections` 등의 이미 정의되어있는 api를 잘 활용하자.

# 3. 주석 사용하기
## 3.1 지나치게 많은 주석은 없애자
- 코드를 통해 이해할 수 있는 내용이면 굳이 주석을 남겨놓지 않아도 좋다.

## 3.2 주석 처리된 코드 제거
- 보통 주석 처리는, 특정 기능을 동작하지 못하게 하거나, 혹은 훗날 다시 사용할지도 모르기 때문에 하는 경우가 많음.
- 그냥 지우자. 
    - 왜? 코드 이해하는데 방해만 된다.
    
## 3.3 주석을 상수로 대체하자
- 의미있는 변수를 대체해놓은 주석은, 남겨두지 말고 상수로 대체하자

## 3.4 주석을 유틸리티 메서드로 대체하자
- Math.to... 이렇게 뭔가 계산하는 코드는 주석으로 어떤 목적인지 알려주는 경우가 많음.
- 그대신 이 부분을 메서드로 대체하자
- 이러면 더 이해하기가 쉬워진다.

## 3.5 구현 결정 설명..
- 왜 `Collections.binarySearch` 를 사용하였을 까?
    - 이 부분을 주석해 놓는 경우가 있음.
- 이러한 주석을 작성할 때 아래 해당 사항을 포함하여 주석을 작성하자
    1. 사용 사례의 맥락에서 
    2. 직면되는 우려사항
    3. 그리고 개발자가 선택한 해법으로
    4. 얻게되는 품질 (장점)과
    5. 받아들여야하는 단점
    - In the context of [USE CASE],
    - facing [CONCERN]
    - we decided for [OPTION]
    - to achieve [QUALITY],
    - accepting [DOWNSIDE].
    
## 3.6 예제로 설명하자
- regex 패턴에 대해 설명
    1. 형식
    2. 유효한 예
    3. 유효하지 않는 예
- 이런식으로 적어두면 해당 코드에 대해 훨씬 이해하기 편할듯!

## 3.7 패키지를 JavaDoc으로 구조화 하기
- JavaDoc은 java api가 제공하는 문서화 기능.

## 3.8 클래스와 인터페이스를 JavaDoc으로 구조화 하기
- 최상단에는 요약문
- 그 다음에 태그를 통해, 상세한 설명

## 3.9 메서드를 JavaDoc으로 구조화 하기
- 메서드는 객체의 동작을 표현
- IDE는 JavaDoc 주석에서 추출한 내용을 기반으로 개발자에게 호출할 메서드를 선택하게 해준다.
- `<pre>`는 xml환경. < 문자를 조심해야함.

## 3.10 생성자를 JavaDoc으로 구조화 하기

# 4. 올바르게 명명하기
## 4.1 자바 명명 규칙 사용
- CamelCase -> 클래스, 인터페이스, enum
- CAPITAL_SNAKE_CASE -> 상수 (final, static..)
- camelCase -> 메서드, 필드 매개변수, 변수..
- 메서드는 동사로 명명, 시작해야함.
    - 왜냐면 메서드명, 변수명이 모두 camelCase 형식이기 떄문에, 명명만 가지고는 헷갈릴 수 있다.
    - 그래서 메서드는 동사를 사용.

## 4.2 프레임워크에는 Getter/Setter 규칙 적용
- JavaBean.. 게터 세터만의 명세서..

## 4.3 한 글자로 명명하지 않기
- 한 글자만으로 변수를 명명했을 경우, 해당 변수가 어떤것을 위한 목적인지 알기 어렵다.
- 그러면 전반적인 코드 가독성에 문제가 생김.

## 4.4 축약 쓰지 않기
- 가능한 축약어 사용은 피하고, **매우** 일반적인 경우에만 사용하라
    - 확신 없다면, 다른 개발자가 이해하리라는.. 반드시 풀어서 작성하자
- 왜? 코드를 보는 모두가 아는 것이 아니므로.
- 누구나 알만한 변수명을 사용하라

## 4.5 무의미한 용어 쓰지 않기
- 무의미하게 변수명을 풀어서 사용하지 말자
    - 차라리 간결한게 낫다.
- 해당 변수가 사용되는 목적을 나타내는 간단한 명명이 나을떄도 있음.
- AbstractSingleTonProxyFactorBean class from Spring framework

## 4.6 도메인 용어 사용하기
- 도메인에 맞게, 내부 변수를 명명하자

# 5. 문제 발생에 대비하기
## 5.1 빠른 실패
- 에러에 대한 핸들링은 코드 작성 초기에 진행되는 것이 좋다.

## 5.2 항상 가장 구체적인 예외 잡기
- 예외를 잡으려면 가장 구체적인 예외를 잡자.
- `Exception` 은 가장 일반적인 예외 유형
    - `Throwable` 은 `Exception` 의 상위 타입인데, 이걸 잡아버리면 OutOfMemoryError 같은 가상 머신내 오류까지 잡힐 수 있으므로, 사용하지 말자
   
## 5.3 메세지로 원인 설명
- 에러 메세지를 통해, 어디서, 어떤 오류가 발생했는지 파악하기 쉽도록 작성하자
- Expected number but got %s in message..

## 5.4 원인 사실을 깨지 말자
- 예외는 또 다른 예외를 발생시킬 수 있음.
- 그래서 예외를 잡았지만, 처리할 수 없는 예외이면 다시 던져야 한다.

## 5.5 변수로 원인 노출
- 맞춤 예외를 만들어서, 이를 이용하자

## 5.6 타입 변환전 항상 타입 검증하기
- 타입 변환시, 적절하게 변환되지 않으면 `RuntimeException` 발생
- `instanceof` 를 사용하자

## 5.7 항상 자원 닫기
- 자원 누출 .. resource leak
- `try-with-resource` 구문을 사용하자 
    - 그러면 문제가 있더라도, 항상 사용했던 자원을 닫을 수있다.
    
## 5.8 항상 다수 자원 닫기
- `try()` 내부에서 여러 자원에 대한 구문은 ; 통해 하면 된다.
- 자원을 직접 관리하지 말자. 반드시 try-with-resource 를 사용하자

## 5.9 빈 catch block 설명하기
- 예외를 넘기고 아무것도 하지 말아야할 때가 있음.
- 예외 변수명을 `ignored` 로 바꾸고, 왜 무시하였는 지 주석으로 설명하자

# 6. 올바르게 드러내기 (테스트)
## 6.1 Given When Then 으로 테스트 구조화
- JUnit ->  자바 단위테스트를 작성하는 사실상 표준 라이브러리..

## 6.2 의미 있는 assertion 사용하기
- assertTrue 보다는 assertEquals 같은  메서드를 사용하자
- 왜? 실패했을 경우, 왜 실패했는지 더 자세히 알 수 있다.

## 6.3 실제 값보다 기대 값을 먼저 보이기
- bad : `Assertions.assertEquals(cruiseControl.getTargetSpeedKmh(), 7667);`
- good : ` Assertions.assertEquals( 7667, cruiseControl.getTargetSpeedKmh());`
- 왜? 에러 로그 찍힐 때, 읽기 편하니까

## 6.4 합당한 허용값 사용하기
- 부동소수점 문제
    - 6₩4 또는 32비트로 소수를 표현하는 방식에서 비롯됨.
    - 부동소수점 수를 모두 유한한 비트 수로 표현하기는 불가능.
    - 그래서 모든 프로그래밍 언어에서는 부동소수점 수를 근사화 함.
    - 소수 0.1은.. 메모리내에서 0.1000000000000000000555115123126... 같은 근사값으로 바뀜.
    - 참고 : https://ssoco.tistory.com/25
- **돈 관련된 문제이는 부동소수점 연산 하지 말자**
    - BigDecimal
    - long 사용
    
## 6.5 예외 처리는 JUnit에 맞기자.
- 특정 예외를 던지는 경우, 어떤 예외가 발생했는지도 검증할 수 있다.
- `Assertions.assertThrows()` 를 사용하자

## 6.6 테스트 설명하기
- `@DisplayName` 어노테이션 사용해서 어떤 테스트 이고, 어떤 결과를 기대하는지 작성하자
- 테스트 삭제는 그냥 삭제하지 않고, 왜 비활성화 하였는지 꼭 설명

## 6.7 독립형 테스트 사용하기
- `@BeforeEach`, `@BeforeAll` 은 테스트 코드의 어떤 부분을 하나로 모으는데는 좋은 역할을 하고 있지만..
    - 전반적인 테스트 코드를 이해하기에는 별로 좋지 않다.
    - 이 부분이 각각 테스트 코드 내부에는 없으니까, 이 코드 실행에 어떤 일이 전제되는지 파악하기 힘들 수 있음.
    
## 6.8 테스트 매개변수화
- `@ParameterizedTest`, `@ValueSource` 를 잘 사용해보자
- 매개변수와 테스트 코드를 분리할 수 있다.

## 6.9 경계 케이스 다루기
- 엣지 케이스
    - 보통.. null "" 빈문자열, " " 여백만 있는 문자열, 특수문자..
    - Integer.MAX_VALUE 등등

# 7. 객체 디자인
## 7.1 메서드가 하나의 작업만 하도록
- 메서드명 만드로도 어떤 동작을 할 지 알아야 하고,

## 7.2 옵션 매개변수로 메서드를 분활
- 옵션 매개변수이다?
- 그 메서드가 실행하는 일 중에.. 해당 매개변수가 꼭 필요하지 않은 부분이 있다.
- 이 옵션 매개변수를 처리하는 부분을 해당 메서드 내에서 분할하면 좋다는 말인듯.

## 7.3 구체 타입보다 추상 타입
- 구체적인 타입 클래스에 한정되기 보다는 추상 클래스, 인터페이스에 의존하도록 하자

## 7.4 가변 상태보다 불변 상태 이용하기
- 멤버변수들에 `final` 을 붙여주자.
- 객체에게 유효하지 않은 변경이 일어나지 않도록
- 이렇게 하면 변경이 필요할 때 마다, 매번 새로운 인스턴스가 필요하게 된다.

## 7.5 상태와 동작 결합
- 멤버 변수는 private 하게, 혹은 접근자를 제공.
- 불필요하게 해당 클래스가 아닌 다른 클래스에서 해당 변수르 조절할 수 있도록 하지 말자.

## 7.6 참조 누수 피하기
- 클래스 내부에 있는 콜렉션이 무분별하게 변경되는 걸 막는게 좋다 왜 참조 누수를 피하기 위해서..
- `Collections.unmodifiableList` 등을 사용
- 방어복사 (defensive copying)

## 7.7 널 반환하지 않기
- 반환할 값이 없으면 null을 반환시키는 경우가 있음 --> 시스템 안정성에 별로 좋지 못하다.
- 그러면 예외를 던지던지.. 
- 권장하는 방법은 Null object pattern을 반환하는 것.
  - 즉 객체를 반환하지만, 개발자가 알 수 있는 이건 Null대신 반환되는 객체를 만들어서 반환하도록 하는 것.
- 이렇게 하면 null때문에 발생하는 시스템 오류(비용이 막심한)을 막을수 있다는 장점이 있다.

# 8. 데이터 흐름
## 8.1 익명클래스 대신 람다 사용하기
- 좋은 IDE는 추천해주기도 함.
- `computeIfAbsent()` : 키를 사용해서 맵에서 값을 얻는데, 맵에 키가 없으면 값을 먼저 계산.
- 익명 클래스 : 클래스명이 없고, 클래스에 인스턴스가 딱 하나만 있는 클래스
- 익명 클래스를 사용하면 코드량이 늘어난다 
  - 그래서 람다를 사용하자
- 람다는 함수형 인터페이스로 단일 추상 메서드가 포함되어 있음.
- 자바에서는 어떤 경우든 타입을 명시적으로 표기해야하지만.. 람다 표현식의 **매개변수** 라면 컴파일러가 타입을 알아서 넣어주므로, 타입을 명시하지 않아도 된다!
  - 타입 추론

## 8.2 명령형 방식 대신 함수형
- 컬렉션에 대한 처리는 함수형으로 하자 왜? 훨씬 읽기 쉽다.
- `filter()` 는 true or false를 판단하는 Predicate 를 받고 있음.

## 8.3 람다 대신 메서드 참조
- 람다 같은 경우, 논리가 더 추가되면 잠재적으로 오류 가능성 있음.
  - 이를 방지하기 위해서는 테스트가 필요한데, 람다 표현식은 참조가 불가능해 단위 테스트에 사용하기도 어려움.
- 그래서 메서드 참조를 이용하자 `Supply::isUncontaminated` 같이
- Predicate 인터페이스에는 (객체를 받아 Boolean을 반환하는 메서드 참조를 사용)
- Function 인터페이스에는 (객체를 받아 객체를 반환하는 메서드 참조를 사용)

## 8.4 부수 효과 피하기
- 스트림을 종료시킬 때, `forEach()` 는 부수효과를 일으킬 가능성이 크므로, 가능한 사용하지 말자.
- 차라리 `collect()` 나 `reduce()` 를 통해 종료하도록 하자

## 8.5 복잡한 스트림 종료시 컬렉트 사용하기
- `Collectors.groupingBy()` Map 자료구조를 반환하는..

## 8.6 스트림 내 예외 피하기
- 스트림에서는 checked exceptiondㅡㄹ 쓸 수 없음.
- `flatMap()` 은 어떤 타입에 다른 타입의 Stream을 맵핑한다.

## 8.7 널 대신 옵셔널
- 이 부분은 포스팅 하자
- if - null check 보다는 Optional을 리턴하도록 하자

## 8.8 선택 필드나 매개변수 피하기
- 선택 필드나, 매개변수로 `Optioanl` 을 사요하는 것은 피하자
- Objects.requireNonNull()..로 Null을 검증하도록 하자

## 8.9 옵셔널을 스트림으로 사용하기
- 옵셔널은 0개 또는 1개 원소만 포함하는 특별한 형태의 **스트림** 임.
- 옵셔널은 함수형 프로그래밍 방식을 위해 만들어졌다.

# 9. 실전 준비
## 9.1 정적 코드 분석 도구
- 컴파일 오류, 기능적 오류를 넘어서 특정 유형의 문제를 코드에서 자동 감지. 심지어 수정까지 도와주는 경우도 있음.
- SpotBugs, Checkstyle, PMD
- Error Prone
- Intellij Code Inspection

## 9.2 팀 내 자바 포맷 통일
- 구글 자바 스타일 가이드를 사용하자

## 9.3 빌드 자동화
- Gradle
- Maven, Ant

## 9.4 지속적 통합
- CI
- Jenkins
- Travis CI

## 9.5 생산 준비와 납품
- Elastic Stack, Graylog를 통해 로그를 통합해서 볼 수 있도록..
- 모든 예외를 모으고 추적할 수 있도록.. 
  - Airbrake(백), Sentry(프론트)

## 9.6 콘솔 출력 대신 로깅
- Log4j , 로깅에 가장 널리 쓰는 프레임워크
- 적절한 로그 레벌 수준 설정 (debug, info, warn, error, fatal)

## 9.7 다중 스레드 코드 최소화 및 독립
- concurrency 동시성
- 다중 스레드는 언제 이용해야할까?
  - 코드를 실행해보고 너무 느리면, 다중 스레드를 이용하도록 하자

## 9.8 고급 동시 실행 추상화 사용하기
- 자바 동시 실행, JVM에서 동시 실행 프로그래밍 참고

## 9.9 프로그램 속도 향상
- `stream().parallel()`
- 스트림 내부를 병렬적으로 실행할 수 있도록 만들어준다.
- 스트림의 일부만 병렬화하는 것은 불가능. 즉 스트림 내에서 sequential() 이나 parallel()을 여러번 호출하여도, 맨 마지막 호출된 코드만 유효하다.

## 9.10 틀린 가정 알기
- 어떠한 법칙 (이름 순서나, 집 주소등... 심지어 날짜까지) 우리가 생각하는 상식에 현실이 항상 부합한다고 생각하지 말자.
- 거기에 모든 경우의 수를 체크하여 대응하기는 불가능.